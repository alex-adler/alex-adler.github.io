// space_time/data/celestial_data.js
var space_time = {
  Mercury: {
    generatedTimeZone: false,
    name: "Mercury",
    GM_km3_s2: 22031.86855,
    GM_km3_s2_primary: 1327e8,
    radius_km: 2440,
    surface_gravity_ms: 3.7005960343321687,
    semiMajorAxis_0_km: 5790907025241733e-8,
    eccentricity_0: 0.2056302515978038,
    inclination_0_deg: 7.005014362233553,
    longitudOfAscendingNode_0_deg: 48.33053877672862,
    argumentOfPeriapsis_0_deg: 29.12427943500334,
    trueAnomaly_0_deg: 175.1155302923815,
    semiMajorAxis_km_Cy: 0,
    eccentricity_Cy: 0,
    inclination_sec_Cy: 0,
    longitudOfAscendingNode_sec_Cy: 0,
    argumentOfPeriapsis_sec_Cy: 0,
    trueAnomaly_sec_Cy: 0,
    period_ms: 7600887337010863e-6,
    meanAnomaly_0_deg: null
  },
  Venus: {
    generatedTimeZone: false,
    name: "Venus",
    GM_km3_s2: 324858.592,
    GM_km3_s2_primary: 1327e8,
    radius_km: 6051.893,
    surface_gravity_ms: 8.869760144761234,
    semiMajorAxis_0_km: 1082081565316098e-7,
    eccentricity_0: 0.006755697268576816,
    inclination_0_deg: 3.394589632757466,
    longitudOfAscendingNode_0_deg: 76.6783751109416,
    argumentOfPeriapsis_0_deg: 55.18541504725159,
    trueAnomaly_0_deg: 49.90452231912491,
    semiMajorAxis_km_Cy: 0,
    eccentricity_Cy: 0,
    inclination_sec_Cy: 0,
    longitudOfAscendingNode_sec_Cy: 0,
    argumentOfPeriapsis_sec_Cy: 0,
    trueAnomaly_sec_Cy: 0,
    period_ms: 19414866312342583e-6,
    meanAnomaly_0_deg: null
  },
  Earth: {
    generatedTimeZone: true,
    name: "Earth",
    dayLength_ms: 864e5,
    yearLength_ms: 31558149e3,
    yearLength_hd: 365,
    hDayLength_ms: 864e5,
    weekLength_d: 7,
    weekLength_hd: 7,
    hYearLength_ms: 31536e6,
    monthCount: 12,
    nominalMonthLength_hd: 30,
    nominalMonthLength_ms: 2592e6,
    leapYearFreq_hd: [4, 158],
    leapYearBlocks_ms: [1262304e5, 4986144e6],
    monthRemainder_hd: 5,
    initialWeekDay: 6,
    initialYearProgress: 0,
    GM_km3_s2: 398600.435436,
    GM_km3_s2_primary: 1327e8,
    radius_km: 6378.137,
    surface_gravity_ms: 9.798285322749217,
    semiMajorAxis_0_km: 1496534962738141e-7,
    eccentricity_0: 0.01704239718110438,
    inclination_0_deg: 2668809336274974e-19,
    longitudOfAscendingNode_0_deg: 163.9748712430063,
    argumentOfPeriapsis_0_deg: 297.7671795415902,
    trueAnomaly_0_deg: 358.1260865474801,
    semiMajorAxis_km_Cy: 0,
    eccentricity_Cy: 0,
    inclination_sec_Cy: 0,
    longitudOfAscendingNode_sec_Cy: 0,
    argumentOfPeriapsis_sec_Cy: 0,
    trueAnomaly_sec_Cy: 0,
    period_ms: 31577279278169163e-6,
    meanAnomaly_0_deg: null
  },
  Mars: {
    generatedTimeZone: true,
    name: "Mars",
    dayLength_ms: 88775e3,
    yearLength_ms: 59266496e3,
    yearLength_hd: 667,
    hDayLength_ms: 88775e3,
    weekLength_d: 7,
    weekLength_hd: 7,
    hYearLength_ms: 59212925e3,
    monthCount: 24,
    nominalMonthLength_hd: 27,
    nominalMonthLength_ms: 2396925e3,
    leapYearFreq_hd: [2, 10],
    leapYearBlocks_ms: [118514625e3, 5926619e5],
    monthRemainder_hd: 19,
    initialWeekDay: 0,
    initialYearProgress: 0,
    GM_km3_s2: 42828.375214,
    GM_km3_s2_primary: 1327e8,
    radius_km: 3396.19,
    surface_gravity_ms: 3.7131940089349422,
    semiMajorAxis_0_km: 2279390120013493e-7,
    eccentricity_0: 0.0933146065415545,
    inclination_0_deg: 1.849876654038142,
    longitudOfAscendingNode_0_deg: 49.56199905920329,
    argumentOfPeriapsis_0_deg: 286.5373583154345,
    trueAnomaly_0_deg: 23.02024685501411,
    semiMajorAxis_km_Cy: 0,
    eccentricity_Cy: 0,
    inclination_sec_Cy: 0,
    longitudOfAscendingNode_sec_Cy: 0,
    argumentOfPeriapsis_sec_Cy: 0,
    trueAnomaly_sec_Cy: 0,
    period_ms: 5935706236500615e-5,
    meanAnomaly_0_deg: null
  },
  Ceres: {
    generatedTimeZone: true,
    name: "Ceres",
    dayLength_ms: 32667e3,
    yearLength_ms: 145423789e3,
    yearLength_hd: 1712,
    weekLength_d: 13,
    weekLength_hd: 5,
    hDayLength_ms: 84934e3,
    hYearLength_ms: 145407008e3,
    monthCount: 84,
    nominalMonthLength_hd: 20,
    nominalMonthLength_ms: 169868e4,
    leapYearFreq_hd: [6, 33],
    leapYearBlocks_ms: [872526982e3, 4798940868e3],
    monthRemainder_hd: 32,
    initialWeekDay: 0,
    initialYearProgress: 0,
    GM_km3_s2: 62.6325,
    GM_km3_s2_primary: 1327e8,
    radius_km: 469.7,
    surface_gravity_ms: 0.2838955771940551,
    semiMajorAxis_0_km: 4138616544134015e-7,
    eccentricity_0: 0.07837505504042046,
    inclination_0_deg: 10.58336067354914,
    longitudOfAscendingNode_0_deg: 80.49436497118826,
    argumentOfPeriapsis_0_deg: 73.92278732202695,
    trueAnomaly_0_deg: 7.121193766358798,
    semiMajorAxis_km_Cy: 0,
    eccentricity_Cy: 0,
    inclination_sec_Cy: 0,
    longitudOfAscendingNode_sec_Cy: 0,
    argumentOfPeriapsis_sec_Cy: 0,
    trueAnomaly_sec_Cy: 0,
    period_ms: 14522025371986575e-5,
    meanAnomaly_0_deg: null
  },
  Jupiter: {
    generatedTimeZone: false,
    name: "Jupiter",
    GM_km3_s2: 1266865319e-1,
    GM_km3_s2_primary: 1327e8,
    radius_km: 71492,
    surface_gravity_ms: 24.786519847888645,
    semiMajorAxis_0_km: 7786731611090481e-7,
    eccentricity_0: 0.04892305962953223,
    inclination_0_deg: 1.304655711046047,
    longitudOfAscendingNode_0_deg: 100.4888615724618,
    argumentOfPeriapsis_0_deg: 275.1197059498091,
    trueAnomaly_0_deg: 20.63463654069944,
    semiMajorAxis_km_Cy: 0,
    eccentricity_Cy: 0,
    inclination_sec_Cy: 0,
    longitudOfAscendingNode_sec_Cy: 0,
    argumentOfPeriapsis_sec_Cy: 0,
    trueAnomaly_sec_Cy: 0,
    period_ms: 37478069809121204e-5,
    meanAnomaly_0_deg: null
  },
  Europa: {
    generatedTimeZone: true,
    name: "Europa",
    dayLength_ms: 306822e3,
    yearLength_ms: 374335776e3,
    yearLength_hd: 4270,
    weekLength_d: 2,
    weekLength_hd: 7,
    hDayLength_ms: 87663e3,
    hYearLength_ms: 37432101e4,
    monthCount: 152,
    nominalMonthLength_hd: 28,
    nominalMonthLength_ms: 2454564e3,
    leapYearFreq_hd: [6, 564],
    leapYearBlocks_ms: [2246013723e3, 211125377625e3],
    monthRemainder_hd: 14,
    initialWeekDay: 0,
    initialYearProgress: 0
  },
  Ganymede: {
    generatedTimeZone: true,
    name: "Ganymede",
    dayLength_ms: 618153e3,
    yearLength_ms: 374335776e3,
    yearLength_hd: 4239,
    weekLength_d: 1,
    weekLength_hd: 7,
    hDayLength_ms: 88307e3,
    hYearLength_ms: 374333373e3,
    monthCount: 148,
    nominalMonthLength_hd: 28,
    nominalMonthLength_ms: 2472596e3,
    leapYearFreq_hd: [37, 5410],
    leapYearBlocks_ms: [13850423108e3, 2025156529059e3],
    monthRemainder_hd: 95,
    initialWeekDay: 0,
    initialYearProgress: 0
  },
  Callisto: {
    generatedTimeZone: true,
    name: "Callisto",
    dayLength_ms: 1441931e3,
    yearLength_ms: 374335776e3,
    yearLength_hd: 4413,
    weekLength_d: 1,
    weekLength_hd: 17,
    hDayLength_ms: 84819e3,
    hYearLength_ms: 374306247e3,
    monthCount: 64,
    nominalMonthLength_hd: 68,
    nominalMonthLength_ms: 5767692e3,
    leapYearFreq_hd: [3, 68],
    leapYearBlocks_ms: [112300356e4, 25454775633e3],
    monthRemainder_hd: 61,
    initialWeekDay: 0,
    initialYearProgress: 0
  },
  Saturn: {
    generatedTimeZone: false,
    name: "Saturn",
    GM_km3_s2: 37931206234e-3,
    GM_km3_s2_primary: 1327e8,
    radius_km: 60268,
    surface_gravity_ms: 10.442947496734448,
    semiMajorAxis_0_km: 1433364815997285e-6,
    eccentricity_0: 0.05559928887285597,
    inclination_0_deg: 2.48436877980734,
    longitudOfAscendingNode_0_deg: 113.6930130794106,
    argumentOfPeriapsis_0_deg: 335.9006492558044,
    trueAnomaly_0_deg: 316.0917716241848,
    semiMajorAxis_km_Cy: 0,
    eccentricity_Cy: 0,
    inclination_sec_Cy: 0,
    longitudOfAscendingNode_sec_Cy: 0,
    argumentOfPeriapsis_sec_Cy: 0,
    trueAnomaly_sec_Cy: 0,
    period_ms: 9360079053995223e-4,
    meanAnomaly_0_deg: null
  },
  Titan: {
    generatedTimeZone: true,
    name: "Titan",
    dayLength_ms: 1377648e3,
    yearLength_ms: 929596607e3,
    yearLength_hd: 10796,
    weekLength_d: 1,
    weekLength_hd: 16,
    hDayLength_ms: 86103e3,
    hYearLength_ms: 929567988e3,
    monthCount: 168,
    nominalMonthLength_hd: 64,
    nominalMonthLength_ms: 5510592e3,
    leapYearFreq_hd: [4, 13],
    leapYearBlocks_ms: [3718358055e3, 12084728256e3],
    monthRemainder_hd: 44,
    initialWeekDay: 0,
    initialYearProgress: 0
  },
  Enceladus: {
    generatedTimeZone: true,
    name: "Enceladus",
    dayLength_ms: 118386e3,
    yearLength_ms: 929596607e3,
    yearLength_hd: 10993,
    weekLength_d: 5,
    weekLength_hd: 7,
    hDayLength_ms: 84561e3,
    hYearLength_ms: 929579073e3,
    monthCount: 392,
    nominalMonthLength_hd: 28,
    nominalMonthLength_ms: 2367708e3,
    leapYearFreq_hd: [5, 136],
    leapYearBlocks_ms: [4647979926e3, 126425121636e3],
    monthRemainder_hd: 17,
    initialWeekDay: 0,
    initialYearProgress: 0
  },
  Uranus: {
    generatedTimeZone: false,
    name: "Uranus",
    GM_km3_s2: 5793951256e-3,
    GM_km3_s2_primary: 1327e8,
    radius_km: 25559,
    surface_gravity_ms: 8.8692545868098,
    semiMajorAxis_0_km: 2876758957338404e-6,
    eccentricity_0: 0.04439336258840319,
    inclination_0_deg: 0.7723604869115734,
    longitudOfAscendingNode_0_deg: 73.96006633963485,
    argumentOfPeriapsis_0_deg: 96.61122696481169,
    trueAnomaly_0_deg: 145.8440420932308,
    semiMajorAxis_km_Cy: 0,
    eccentricity_Cy: 0,
    inclination_sec_Cy: 0,
    longitudOfAscendingNode_sec_Cy: 0,
    argumentOfPeriapsis_sec_Cy: 0,
    trueAnomaly_sec_Cy: 0,
    period_ms: 26613354438382827e-4,
    meanAnomaly_0_deg: null
  },
  Titania: {
    generatedTimeZone: true,
    name: "Titania",
    dayLength_ms: 752218e3,
    yearLength_ms: 26514864e5,
    yearLength_hd: 31724,
    weekLength_d: 1,
    weekLength_hd: 9,
    hDayLength_ms: 83579e3,
    hYearLength_ms: 2651460196e3,
    monthCount: 880,
    nominalMonthLength_hd: 36,
    nominalMonthLength_ms: 3008844e3,
    leapYearFreq_hd: [4, 16],
    leapYearBlocks_ms: [10605924363e3, 42423781031e3],
    monthRemainder_hd: 44,
    initialWeekDay: 0,
    initialYearProgress: 0
  },
  Neptune: {
    generatedTimeZone: false,
    name: "Neptune",
    GM_km3_s2: 683509997e-2,
    GM_km3_s2_primary: 1327e8,
    radius_km: 24766,
    surface_gravity_ms: 11.14379550029934,
    semiMajorAxis_0_km: 4503002396427352e-6,
    eccentricity_0: 0.01127490587339749,
    inclination_0_deg: 1.764331194766304,
    longitudOfAscendingNode_0_deg: 131.8103417756993,
    argumentOfPeriapsis_0_deg: 266.115451343762,
    trueAnomaly_0_deg: 265.9963939182547,
    semiMajorAxis_km_Cy: 0,
    eccentricity_Cy: 0,
    inclination_sec_Cy: 0,
    longitudOfAscendingNode_sec_Cy: 0,
    argumentOfPeriapsis_sec_Cy: 0,
    trueAnomaly_sec_Cy: 0,
    period_ms: 5211919197601552e-3,
    meanAnomaly_0_deg: null
  },
  Triton: {
    generatedTimeZone: true,
    name: "Triton",
    dayLength_ms: 50776e4,
    yearLength_ms: 51997248e5,
    yearLength_hd: 61443,
    weekLength_d: 1,
    weekLength_hd: 6,
    hDayLength_ms: 84626e3,
    hYearLength_ms: 5199675318e3,
    monthCount: 2560,
    nominalMonthLength_hd: 24,
    nominalMonthLength_ms: 2031024e3,
    leapYearFreq_hd: [2, 12],
    leapYearBlocks_ms: [10399435262e3, 62396696198e3],
    monthRemainder_hd: 3,
    initialWeekDay: 0,
    initialYearProgress: 0
  }
};

// node_modules/ts-matrix/dist/ts-matrix.mjs
var x = Object.defineProperty;
var d = (y, t, s) => t in y ? x(y, t, { enumerable: true, configurable: true, writable: true, value: s }) : y[t] = s;
var m = (y, t, s) => (d(y, typeof t != "symbol" ? t + "" : t, s), s);
var c = class _c {
  constructor(t, s, e) {
    m(this, "_rows");
    m(this, "_columns");
    m(this, "_values");
    this._rows = Math.max(t, 1), this._columns = Math.max(s, 1), this._values = new Array(this._rows).fill([]).map(() => new Array(this._columns).fill(0)), e && (this.values = e);
  }
  get rows() {
    return this._rows;
  }
  get columns() {
    return this._columns;
  }
  get values() {
    return this._values;
  }
  set values(t) {
    const s = Math.min(t.length, this.rows), e = Math.min(t[0].length, this.columns);
    for (let r = 0; r < s; r++)
      for (let n = 0; n < e; n++)
        this.values[r][n] = t[r][n];
  }
  at(t, s) {
    return this.values[t][s];
  }
  reset() {
    this.values = this.values.map((t) => t.map(() => 0));
  }
  addAColumn() {
    return new _c(this.rows, this.columns + 1, this.values);
  }
  addARow() {
    return new _c(this.rows + 1, this.columns, this.values);
  }
  equals(t) {
    return this.rows === t.rows && this.columns === t.columns && this.values.reduce(
      (s, e, r) => s && e.reduce(
        (n, i, o) => n && t.at(r, o) === i,
        s
      ),
      true
    );
  }
  setAsIdentity() {
    if (this.rows !== this.columns)
      throw new Error("Dimension error! The matrix isn't squared!");
    return this.values.forEach((t, s) => {
      t.forEach((e, r) => {
        this.values[s][r] = s === r ? 1 : 0;
      });
    }), this;
  }
  static identity(t) {
    if (t < 1)
      throw Error("Dimension error! Matrix dimension must be positive.");
    return new _c(t, t).setAsIdentity();
  }
  multiply(t) {
    if (this.columns !== t.rows)
      throw new Error("Dimension error! The operand matrix must have the same number of rows as 'this' matrix columns!");
    const s = new _c(this.rows, t.columns);
    return s.values = s.values.map((e, r) => e.map((n, i) => this.values[r].reduce((o, h, a) => o + h * t.at(a, i), 0))), s;
  }
  indexOf(t) {
    for (let s = 0; s < this.rows; s++)
      for (let e = 0; e < this.columns; e++)
        if (this.values[s][e] === t)
          return [s, e];
    return [-1, -1];
  }
  max() {
    return this.values.reduce((t, s) => Math.max(t, ...s), -1 / 0);
  }
  min() {
    return this.values.reduce((t, s) => Math.min(t, ...s), 1 / 0);
  }
  round() {
    return new _c(this.rows, this.columns, this.values.map((t) => t.map((s) => Math.round(s))));
  }
  determinant() {
    if (this.rows !== this.columns)
      throw new Error("Dimension error! The matrix isn't squared!");
    if (this.rows === this.columns && this.columns === 1)
      return this.values[0][0];
    let t = 0, s = 1;
    if (this.rows === 2)
      t = this.values[0][0] * this.values[1][1] - this.values[1][0] * this.values[0][1];
    else
      for (let e = 0; e < this.rows; e++) {
        const r = this.getCofactor(0, e);
        t += s * this.at(0, e) * r.determinant(), s = -s;
      }
    return t;
  }
  getCofactor(t, s) {
    return new _c(this.rows - 1, this.columns - 1, this.values.filter((e, r) => r !== t).map((e) => e.filter((r, n) => n !== s)));
  }
  transpose() {
    return new _c(this.columns, this.rows, new Array(this.columns).fill([]).map((t, s) => new Array(this.rows).fill(0).map((e, r) => this.at(r, s))));
  }
  inverse() {
    if (this.rows !== this.columns)
      throw new Error("Dimension error! The matrix isn't squared!");
    const t = this.determinant();
    if (t === 0)
      throw new Error("Determinant is 0, can't compute inverse.");
    const e = new _c(
      this.rows,
      this.columns,
      this.values.map((r, n) => r.map((i, o) => Math.pow(-1, n + o) * this.getCofactor(n, o).determinant()))
    ).transpose();
    return new _c(
      this.rows,
      this.columns,
      this.values.map((r, n) => r.map((i, o) => e.at(n, o) / t))
    );
  }
  toString() {
    return `[${this.values.map((t) => `[${t.join(", ")}]`).join(`,
`)}]`;
  }
};
var z = 1e-5;
var w = class {
  constructor(t) {
    m(this, "values", new Float32Array(4));
    t !== void 0 && (this.xyzw = t);
  }
  get x() {
    return this.values[0];
  }
  set x(t) {
    this.values[0] = t;
  }
  get y() {
    return this.values[1];
  }
  set y(t) {
    this.values[1] = t;
  }
  get z() {
    return this.values[2];
  }
  set z(t) {
    this.values[2] = t;
  }
  get w() {
    return this.values[3];
  }
  set w(t) {
    this.values[3] = t;
  }
  get xy() {
    return [
      this.values[0],
      this.values[1]
    ];
  }
  set xy(t) {
    this.values[0] = t[0], this.values[1] = t[1];
  }
  get xyz() {
    return [
      this.values[0],
      this.values[1],
      this.values[2]
    ];
  }
  set xyz(t) {
    this.values[0] = t[0], this.values[1] = t[1], this.values[2] = t[2];
  }
  get xyzw() {
    return [
      this.values[0],
      this.values[1],
      this.values[2],
      this.values[3]
    ];
  }
  set xyzw(t) {
    this.values[0] = t[0], this.values[1] = t[1], this.values[2] = t[2], this.values[3] = t[3];
  }
  at(t) {
    return this.values[t];
  }
  reset() {
    for (let t = 0; t < 4; t++)
      this.values[t] = 0;
  }
  copy(t) {
    t || (t = new w());
    for (let s = 0; s < 4; s++)
      t.values[s] = this.values[s];
    return t;
  }
  roll() {
    const t = this.x, s = this.y, e = this.z, r = this.w;
    return Math.atan2(2 * (t * s + r * e), r * r + t * t - s * s - e * e);
  }
  pitch() {
    const t = this.x, s = this.y, e = this.z, r = this.w;
    return Math.atan2(2 * (s * e + r * t), r * r - t * t - s * s + e * e);
  }
  yaw() {
    return Math.asin(2 * (this.x * this.z - this.w * this.y));
  }
  equals(t, s = z) {
    for (let e = 0; e < 4; e++)
      if (Math.abs(this.values[e] - t.at(e)) > s)
        return false;
    return true;
  }
  setIdentity() {
    return this.x = 0, this.y = 0, this.z = 0, this.w = 1, this;
  }
  calculateW() {
    const t = this.x, s = this.y, e = this.z;
    return this.w = -Math.sqrt(Math.abs(1 - t * t - s * s - e * e)), this;
  }
  inverse() {
    const t = w.dot(this, this);
    if (!t)
      return this.xyzw = [0, 0, 0, 0], this;
    const s = t ? 1 / t : 0;
    return this.x *= -s, this.y *= -s, this.z *= -s, this.w *= s, this;
  }
  conjugate() {
    return this.values[0] *= -1, this.values[1] *= -1, this.values[2] *= -1, this;
  }
  length() {
    const t = this.x, s = this.y, e = this.z, r = this.w;
    return Math.sqrt(t * t + s * s + e * e + r * r);
  }
  normalize(t) {
    t || (t = this);
    const s = this.x, e = this.y, r = this.z, n = this.w;
    let i = Math.sqrt(s * s + e * e + r * r + n * n);
    return i ? (i = 1 / i, t.x = s * i, t.y = e * i, t.z = r * i, t.w = n * i, t) : (t.x = 0, t.y = 0, t.z = 0, t.w = 0, t);
  }
  add(t) {
    for (let s = 0; s < 4; s++)
      this.values[s] += t.at(s);
    return this;
  }
  multiply(t) {
    const s = this.values[0], e = this.values[1], r = this.values[2], n = this.values[3], i = t.x, o = t.y, h = t.z, a = t.w;
    return this.x = s * a + n * i + e * h - r * o, this.y = e * a + n * o + r * i - s * h, this.z = r * a + n * h + s * o - e * i, this.w = n * a - s * i - e * o - r * h, this;
  }
  static dot(t, s) {
    return t.x * s.x + t.y * s.y + t.z * s.z + t.w * s.w;
  }
  static sum(t, s) {
    const e = new w();
    return e.x = t.x + s.x, e.y = t.y + s.y, e.z = t.z + s.z, e.w = t.w + s.w, e;
  }
  static product(t, s) {
    const e = new w(), r = t.x, n = t.y, i = t.z, o = t.w, h = s.x, a = s.y, u = s.z, l = s.w;
    return e.x = r * l + o * h + n * u - i * a, e.y = n * l + o * a + i * h - r * u, e.z = i * l + o * u + r * a - n * h, e.w = o * l - r * h - n * a - i * u, e;
  }
  static cross(t, s) {
    const e = new w(), r = t.x, n = t.y, i = t.z, o = t.w, h = s.x, a = s.y, u = s.z, l = s.w;
    return e.x = o * u + i * l + r * a - n * h, e.y = o * l - r * h - n * a - i * u, e.z = o * h + r * l + n * u - i * a, e.w = o * a + n * l + i * h - r * u, e;
  }
  static shortMix(t, s, e) {
    const r = new w();
    if (e <= 0)
      return r.xyzw = t.xyzw, r;
    if (e >= 1)
      return r.xyzw = s.xyzw, r;
    let n = w.dot(t, s);
    const i = s.copy();
    n < 0 && (i.inverse(), n = -n);
    let o, h;
    if (n > 0.9999)
      o = 1 - e, h = 0 + e;
    else {
      const a = Math.sqrt(1 - n * n), u = Math.atan2(a, n), l = 1 / a;
      o = Math.sin((1 - e) * u) * l, h = Math.sin((0 + e) * u) * l;
    }
    return r.x = o * t.x + h * i.x, r.y = o * t.y + h * i.y, r.z = o * t.z + h * i.z, r.w = o * t.w + h * i.w, r;
  }
  static mix(t, s, e) {
    const r = new w(), n = t.x * s.x + t.y * s.y + t.z * s.z + t.w * s.w;
    if (Math.abs(n) >= 1)
      return r.xyzw = t.xyzw, r;
    const i = Math.acos(n), o = Math.sqrt(1 - n * n);
    if (Math.abs(o) < 1e-3)
      return r.x = t.x * 0.5 + s.x * 0.5, r.y = t.y * 0.5 + s.y * 0.5, r.z = t.z * 0.5 + s.z * 0.5, r.w = t.w * 0.5 + s.w * 0.5, r;
    const h = Math.sin((1 - e) * i) / o, a = Math.sin(e * i) / o;
    return r.x = t.x * h + s.x * a, r.y = t.y * h + s.y * a, r.z = t.z * h + s.z * a, r.w = t.w * h + s.w * a, r;
  }
  static fromAxisAngle(t, s) {
    if (t.rows !== 3)
      throw new Error("The axis vector must be in 3D!");
    const e = new w();
    s *= 0.5;
    const r = Math.sin(s);
    return e.x = t.at(0) * r, e.y = t.at(1) * r, e.z = t.at(2) * r, e.w = Math.cos(s), e;
  }
};
var f = w;
m(f, "identity", new w().setIdentity());

// transit/map.ts
var AU_km = 1496e5;
var scalePerKm = 1 / (5 * AU_km);
var Orbit = class {
  constructor(a_km, e, i_deg, longitudeOfAscendingNode_deg, argumentOfPeriapsis_deg, meanAnomaly_deg, GM_km3_s2, GM_km3_s2_primary, radius_km) {
    this.GM_km3_s2 = 0;
    this.GM_km3_s2_primary = 0;
    this.semiMajorAxis_km = 0;
    this.eccentricity = 0;
    this.inclination_deg = 0;
    this.inclination_rad = 0;
    this.longitudeOfAscendingNode_deg = 0;
    this.longitudeOfAscendingNode_rad = 0;
    this.argumentOfPeriapsis_deg = 0;
    this.argumentOfPeriapsis_rad = 0;
    this.meanAnomaly_0_deg = 0;
    this.meanAnomaly_0_rad = 0;
    this.semiMinorAxis_km = 0;
    this.meanAnomaly_deg = 0;
    this.meanAnomaly_rad = 0;
    this.eccentricAnomaly_deg = 0;
    this.trueAnomaly_rad = 0;
    this.trueAnomaly_deg = 0;
    this.radius_km = 0;
    this.positionVector_perifocalFrame = new c(3, 1);
    this.positionVector_inertialFrame = new c(3, 1);
    this.semiMajorAxis_km = a_km;
    if (e !== void 0)
      this.eccentricity = e;
    if (!isNaN(i_deg))
      this.inclination_deg = i_deg;
    this.longitudeOfAscendingNode_deg = longitudeOfAscendingNode_deg;
    this.argumentOfPeriapsis_deg = argumentOfPeriapsis_deg;
    this.meanAnomaly_0_deg = meanAnomaly_deg;
    this.meanAnomaly_0_rad = degToRad(this.meanAnomaly_0_deg);
    this.semiMinorAxis_km = a_km * Math.sqrt(1 - this.eccentricity ** 2);
    this.GM_km3_s2 = GM_km3_s2;
    this.GM_km3_s2_primary = GM_km3_s2_primary;
    this.radius_km = radius_km;
    this.updatePosition(0);
  }
  draw(ctx, canvasUnit, reset, currentScale) {
    if (this.semiMajorAxis_km == void 0)
      return;
    let scale = canvasUnit * scalePerKm;
    let ellipseCenter = {
      x: Math.cos(degToRad(this.longitudeOfAscendingNode_deg + this.argumentOfPeriapsis_deg)) * this.eccentricity * this.semiMajorAxis_km * scale,
      y: Math.sin(degToRad(this.longitudeOfAscendingNode_deg + this.argumentOfPeriapsis_deg)) * this.eccentricity * this.semiMajorAxis_km * scale
    };
    let ellipseCenterMagnitude = Math.sqrt(ellipseCenter.x ** 2 + ellipseCenter.y ** 2);
    ctx.beginPath();
    ctx.fillStyle = "coral";
    ctx.arc(
      this.positionVector_inertialFrame.values[0][0] * scale,
      this.positionVector_inertialFrame.values[1][0] * scale,
      this.radius_km * scale,
      // 5 / currentScale,
      0,
      2 * Math.PI
    );
    ctx.fill();
    let largeSide = ellipseCenterMagnitude + this.semiMajorAxis_km * scale;
    var width = 0.5 / currentScale;
    if (currentScale > 100) {
      width /= (currentScale - 100) / 10;
    }
    ctx.lineWidth = width;
    let colourAngle_deg = this.trueAnomaly_deg + this.longitudeOfAscendingNode_deg + this.argumentOfPeriapsis_deg;
    let colourAngle_rad = degToRad(colourAngle_deg);
    var brightHalf = ctx.createLinearGradient(
      largeSide * Math.cos(colourAngle_rad),
      largeSide * Math.sin(colourAngle_rad),
      -largeSide * Math.cos(colourAngle_rad),
      -largeSide * Math.sin(colourAngle_rad)
    );
    var darkHalf = ctx.createLinearGradient(
      largeSide * Math.cos(colourAngle_rad),
      largeSide * Math.sin(colourAngle_rad),
      -largeSide * Math.cos(colourAngle_rad),
      -largeSide * Math.sin(colourAngle_rad)
    );
    brightHalf.addColorStop(0, "white");
    brightHalf.addColorStop(1, "DimGray");
    darkHalf.addColorStop(1, "DimGray");
    darkHalf.addColorStop(0, "#202020");
    ctx.save();
    ctx.beginPath();
    ctx.rotate(colourAngle_rad);
    ctx.rect(-largeSide - width, -largeSide - width, (largeSide + width) * 2, largeSide + width * 2);
    reset();
    ctx.clip();
    ctx.strokeStyle = darkHalf;
    ctx.beginPath();
    ctx.ellipse(
      -ellipseCenter.x,
      -ellipseCenter.y,
      this.semiMajorAxis_km * scale,
      this.semiMinorAxis_km * scale,
      degToRad(this.longitudeOfAscendingNode_deg + this.argumentOfPeriapsis_deg),
      0 * Math.PI,
      2 * Math.PI
    );
    ctx.stroke();
    ctx.restore();
    ctx.save();
    ctx.beginPath();
    ctx.rotate(colourAngle_rad);
    ctx.rect(-largeSide - width, -width, (largeSide + width) * 2, largeSide + width * 2);
    reset();
    ctx.clip();
    ctx.strokeStyle = brightHalf;
    ctx.beginPath();
    ctx.ellipse(
      -ellipseCenter.x,
      -ellipseCenter.y,
      this.semiMajorAxis_km * scale,
      this.semiMinorAxis_km * scale,
      degToRad(this.longitudeOfAscendingNode_deg + this.argumentOfPeriapsis_deg),
      0 * Math.PI,
      2 * Math.PI
    );
    ctx.stroke();
    ctx.restore();
  }
  keplersEquation(E_rad) {
    return E_rad - this.eccentricity * Math.sin(E_rad) - degToRad(this.meanAnomaly_deg);
  }
  updatePositionVector() {
    let eccentricAnomaly_rad = newtonRaphson(this.keplersEquation.bind(this), degToRad(this.meanAnomaly_deg), null);
    this.eccentricAnomaly_deg = radToDeg(eccentricAnomaly_rad);
    this.trueAnomaly_rad = 2 * Math.atan2(
      (1 + this.eccentricity) ** 0.5 * Math.sin(eccentricAnomaly_rad / 2),
      (1 - this.eccentricity) ** 0.5 * Math.cos(eccentricAnomaly_rad / 2)
    );
    this.trueAnomaly_deg = radToDeg(this.trueAnomaly_rad);
    let semiLatusRectum = this.semiMajorAxis_km * (1 - this.eccentricity ** 2);
    let r = semiLatusRectum / (1 + this.eccentricity * Math.cos(this.trueAnomaly_rad));
    this.positionVector_perifocalFrame.values = [[r * Math.cos(this.trueAnomaly_rad)], [r * Math.sin(this.trueAnomaly_rad)], [0]];
    let Q = new c(3, 3, [
      [
        Math.cos(this.longitudeOfAscendingNode_rad) * Math.cos(this.argumentOfPeriapsis_rad) - Math.cos(this.inclination_rad) * Math.sin(this.longitudeOfAscendingNode_rad) * Math.sin(this.argumentOfPeriapsis_rad),
        -Math.cos(this.longitudeOfAscendingNode_rad) * Math.sin(this.argumentOfPeriapsis_rad) - Math.cos(this.inclination_rad) * Math.cos(this.argumentOfPeriapsis_rad) * Math.sin(this.longitudeOfAscendingNode_rad),
        Math.sin(this.longitudeOfAscendingNode_rad) * Math.sin(this.inclination_rad)
      ],
      [
        Math.cos(this.argumentOfPeriapsis_rad) * Math.sin(this.longitudeOfAscendingNode_rad) + Math.cos(this.longitudeOfAscendingNode_rad) * Math.cos(this.inclination_rad) * Math.sin(this.argumentOfPeriapsis_rad),
        Math.cos(this.longitudeOfAscendingNode_rad) * Math.cos(this.inclination_rad) * Math.cos(this.argumentOfPeriapsis_rad) - Math.sin(this.longitudeOfAscendingNode_rad) * Math.sin(this.argumentOfPeriapsis_rad),
        -Math.cos(this.longitudeOfAscendingNode_rad) * Math.sin(this.inclination_rad)
      ],
      [
        Math.sin(this.inclination_rad) * Math.sin(this.argumentOfPeriapsis_rad),
        Math.cos(this.argumentOfPeriapsis_rad) * Math.sin(this.inclination_rad),
        Math.cos(this.inclination_rad)
      ]
    ]);
    this.positionVector_inertialFrame = Q.multiply(this.positionVector_perifocalFrame);
  }
  updatePosition(t_ms) {
    this.argumentOfPeriapsis_rad = degToRad(this.argumentOfPeriapsis_deg);
    this.inclination_rad = degToRad(this.inclination_deg);
    this.longitudeOfAscendingNode_rad = degToRad(this.longitudeOfAscendingNode_deg);
    this.meanAnomaly_rad = (this.meanAnomaly_0_rad + t_ms / 1e3 * (this.GM_km3_s2_primary / this.semiMajorAxis_km ** 3) ** 0.5) % (2 * Math.PI);
    this.meanAnomaly_deg = radToDeg(this.meanAnomaly_rad);
    this.updatePositionVector();
  }
};
function newtonRaphson(f2, x0, options) {
  var x1, y, yp, tol, maxIter, iter, yph, ymh, yp2h, ym2h, h, hr, verbose, eps;
  let fp = null;
  options = options || {};
  tol = options.tolerance === void 0 ? 1e-7 : options.tolerance;
  eps = options.epsilon === void 0 ? 2220446049250313e-31 : options.epsilon;
  maxIter = options.maxIterations === void 0 ? 20 : options.maxIterations;
  h = options.h === void 0 ? 1e-4 : options.h;
  verbose = options.verbose === void 0 ? false : options.verbose;
  hr = 1 / h;
  iter = 0;
  while (iter++ < maxIter) {
    y = f2(x0);
    yph = f2(x0 + h);
    ymh = f2(x0 - h);
    yp2h = f2(x0 + 2 * h);
    ym2h = f2(x0 - 2 * h);
    yp = (ym2h - yp2h + 8 * (yph - ymh)) * hr / 12;
    if (Math.abs(yp) <= eps * Math.abs(y)) {
      if (verbose) {
        console.log("Newton-Raphson: failed to converged due to nearly zero first derivative");
      }
      return 0;
    }
    x1 = x0 - y / yp;
    if (Math.abs(x1 - x0) <= tol * Math.abs(x1)) {
      if (verbose) {
        console.log("Newton-Raphson: converged to x = " + x1 + " after " + iter + " iterations");
      }
      return x1;
    }
    x0 = x1;
  }
  if (verbose) {
    console.log("Newton-Raphson: Maximum iterations reached (" + maxIter + ")");
  }
  return 0;
}
function degToRad(degrees) {
  return degrees * (Math.PI / 180);
}
function radToDeg(radians) {
  return radians * (180 / Math.PI);
}

// transit/infinite_canvas.ts
var view = /* @__PURE__ */ (() => {
  const matrix = [1, 0, 0, 1, 0, 0];
  var m2 = matrix;
  var scale = 1;
  var ctx;
  const pos = { x: 0, y: 0 };
  var dirty = true;
  const API = {
    set context(_ctx) {
      ctx = _ctx;
      dirty = true;
    },
    apply() {
      if (dirty) {
        this.update();
      }
      ctx.setTransform(m2[0], m2[1], m2[2], m2[3], m2[4], m2[5]);
    },
    get scale() {
      return scale;
    },
    get position() {
      return pos;
    },
    setDirty() {
      dirty = true;
    },
    isDirty() {
      return dirty;
    },
    update() {
      dirty = false;
      m2[3] = m2[0] = scale;
      m2[2] = m2[1] = 0;
      m2[4] = pos.x;
      m2[5] = pos.y;
    },
    pan(amount) {
      if (dirty) {
        this.update();
      }
      pos.x += amount.x;
      pos.y += amount.y;
      dirty = true;
    },
    scaleAt(at, amount) {
      if (dirty) {
        this.update();
      }
      scale *= amount;
      pos.x = at.x - (at.x - pos.x) * amount;
      pos.y = at.y - (at.y - pos.y) * amount;
      dirty = true;
    }
  };
  return API;
})();
var InfiniteCanvas = class {
  constructor(canvas) {
    this.#pixelRatio = window.devicePixelRatio;
    this.cameraZoom = 1;
    this.MAX_ZOOM = 5;
    this.MIN_ZOOM = 0.1;
    this.SCROLL_SENSITIVITY = 5e-4;
    this.isDragging = false;
    this.dragStart = { x: 0, y: 0 };
    this.cameraOffset = { x: 0, y: 0 };
    this.initialPinchDistance = 0;
    this.lastZoom = 1;
    this.lastDrawnZoom = 1;
    this.mouse = { x: 0, y: 0, oldX: 0, oldY: 0, button: false };
    this.#drawFunctions = [];
    this.#needsUpdating = [];
    let temp_context = canvas.getContext("2d");
    if (!temp_context) {
      console.log("Failed to get context");
      return;
    }
    view.context = temp_context;
    this.context = temp_context;
    this.canvas = canvas;
    this.#setupEvents(canvas);
    this.canvas.width = this.canvas.clientWidth * this.#pixelRatio;
    this.canvas.height = this.canvas.clientHeight * this.#pixelRatio;
    this.cameraOffset.x = this.canvas.width / 2;
    this.cameraOffset.y = this.canvas.height / 2;
    view.pan({ x: this.canvas.width / 2, y: this.canvas.height / 2 });
    this.#draw();
  }
  #pixelRatio;
  #drawFunctions;
  #needsUpdating;
  addDrawFunction(drawFunction, needsUpdating) {
    this.#drawFunctions.push(drawFunction);
    this.#needsUpdating.push(needsUpdating);
  }
  #draw() {
    if (view.isDirty() || this.#needsUpdating.length && this.#needsUpdating.some((e) => e())) {
      this.canvas.width = this.canvas.clientWidth * this.#pixelRatio;
      this.canvas.height = this.canvas.clientHeight * this.#pixelRatio;
      this.context.setTransform(1, 0, 0, 1, 0, 0);
      this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
      view.apply();
      let that = this;
      if (this.#drawFunctions.length)
        this.#drawFunctions.map((f2) => f2(that.context, that.canvas.width / 2, view.apply, view.scale));
    }
    requestAnimationFrame(this.#draw.bind(this));
  }
  #setupEvents(canvas) {
    canvas.addEventListener("mousemove", this.mouseEvent.bind(this), { passive: true });
    canvas.addEventListener("mousedown", this.mouseEvent.bind(this), { passive: true });
    canvas.addEventListener("mouseup", this.mouseEvent.bind(this), { passive: true });
    canvas.addEventListener("mouseout", this.mouseEvent.bind(this), { passive: true });
    canvas.addEventListener("wheel", this.mouseWheelEvent.bind(this), { passive: false });
    window.addEventListener("resize", () => view.setDirty());
  }
  mouseEvent(event) {
    if (event.type === "mousedown") {
      this.mouse.button = true;
    }
    if (event.type === "mouseup" || event.type === "mouseout") {
      this.mouse.button = false;
    }
    this.mouse.oldX = this.mouse.x;
    this.mouse.oldY = this.mouse.y;
    this.mouse.x = event.offsetX;
    this.mouse.y = event.offsetY;
    if (this.mouse.button) {
      view.pan({ x: this.mouse.x - this.mouse.oldX, y: this.mouse.y - this.mouse.oldY });
    }
  }
  mouseWheelEvent(event) {
    var x2 = event.offsetX;
    var y = event.offsetY;
    if (event.deltaY < 0) {
      view.scaleAt({ x: x2, y }, 1.1);
    } else {
      view.scaleAt({ x: x2, y }, 1 / 1.1);
    }
    event.preventDefault();
  }
  // Gets the relevant location from a mouse or single touch event
  // #getEventLocation(e: TouchEvent | MouseEvent): { x: number; y: number } {
  // 	if (e instanceof MouseEvent && e.clientX && e.clientY) {
  // 		return { x: e.clientX, y: e.clientY };
  // 	} else if (e instanceof TouchEvent && e.touches && e.touches.length == 1) {
  // 		return { x: e.touches[0].clientX, y: e.touches[0].clientY };
  // 	} else return { x: 0, y: 0 };
  // }
  // #onPointerDown(e: TouchEvent | MouseEvent): void {
  // 	this.isDragging = true;
  // 	this.dragStart.x = this.#getEventLocation(e).x / this.cameraZoom - this.cameraOffset.x;
  // 	this.dragStart.y = this.#getEventLocation(e).y / this.cameraZoom - this.cameraOffset.y;
  // }
  // #onPointerUp(e: TouchEvent | MouseEvent): void {
  // 	this.isDragging = false;
  // 	this.initialPinchDistance = null;
  // 	this.lastZoom = this.cameraZoom;
  // }
  // #onPointerMove(e: TouchEvent | MouseEvent): void {
  // 	if (this.isDragging) {
  // 		this.cameraOffset.x = this.#getEventLocation(e).x / this.cameraZoom - this.dragStart.x;
  // 		this.cameraOffset.y = this.#getEventLocation(e).y / this.cameraZoom - this.dragStart.y;
  // 	}
  // 	var rect = this.canvas.getBoundingClientRect();
  // 	this.#pointerPos.x =
  // 		(((this.#getEventLocation(e).x - rect.left) / (rect.right - rect.left)) * this.canvas.width) / this.cameraZoom - this.cameraOffset.x;
  // 	this.#pointerPos.y =
  // 		(((this.#getEventLocation(e).y - rect.top) / (rect.bottom - rect.top)) * this.canvas.height) / this.cameraZoom - this.cameraOffset.y;
  // }
  // #handleTouch(e: TouchEvent, singleTouchHandler: (e: TouchEvent) => void) {
  // 	if (e.touches.length == 1) {
  // 		singleTouchHandler(e);
  // 	} else if (e.type == "touchmove" && e.touches.length == 2) {
  // 		this.isDragging = false;
  // 		this.#handlePinch(e);
  // 	}
  // }
  // #handlePinch(e: TouchEvent) {
  // 	e.preventDefault();
  // 	let touch1 = { x: e.touches[0].clientX, y: e.touches[0].clientY };
  // 	let touch2 = { x: e.touches[1].clientX, y: e.touches[1].clientY };
  // 	// This is distance squared, but no need for an expensive sqrt as it's only used in ratio
  // 	let currentDistance = (touch1.x - touch2.x) ** 2 + (touch1.y - touch2.y) ** 2;
  // 	if (initialPinchDistance == null) {
  // 		initialPinchDistance = currentDistance;
  // 	} else {
  // 		this.#adjustZoom(null, currentDistance / initialPinchDistance);
  // 	}
  // }
  // #adjustZoom(zoomAmount: number, zoomFactor: number = null): void {
  // 	if (!this.isDragging) {
  // 		if (zoomAmount) {
  // 			this.cameraZoom += zoomAmount;
  // 		} else if (zoomFactor) {
  // 			console.log(zoomFactor);
  // 			this.cameraZoom = zoomFactor * lastZoom;
  // 		}
  // 		this.cameraZoom = Math.min(this.cameraZoom, this.MAX_ZOOM);
  // 		this.cameraZoom = Math.max(this.cameraZoom, this.MIN_ZOOM);
  // 	}
  // }
};

// transit/transit_rs.js
var wasm;
function add(left, right) {
  const ret = wasm.add(left, right);
  return ret >>> 0;
}
async function __wbg_load(module, imports) {
  if (typeof Response === "function" && module instanceof Response) {
    if (typeof WebAssembly.instantiateStreaming === "function") {
      try {
        return await WebAssembly.instantiateStreaming(module, imports);
      } catch (e) {
        if (module.headers.get("Content-Type") != "application/wasm") {
          console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);
        } else {
          throw e;
        }
      }
    }
    const bytes = await module.arrayBuffer();
    return await WebAssembly.instantiate(bytes, imports);
  } else {
    const instance = await WebAssembly.instantiate(module, imports);
    if (instance instanceof WebAssembly.Instance) {
      return { instance, module };
    } else {
      return instance;
    }
  }
}
function __wbg_get_imports() {
  const imports = {};
  imports.wbg = {};
  return imports;
}
function __wbg_init_memory(imports, maybe_memory) {
}
function __wbg_finalize_init(instance, module) {
  wasm = instance.exports;
  __wbg_init.__wbindgen_wasm_module = module;
  return wasm;
}
async function __wbg_init(input) {
  if (wasm !== void 0)
    return wasm;
  if (typeof input === "undefined") {
    input = new URL("transit_rs_bg.wasm", import.meta.url);
  }
  const imports = __wbg_get_imports();
  if (typeof input === "string" || typeof Request === "function" && input instanceof Request || typeof URL === "function" && input instanceof URL) {
    input = fetch(input);
  }
  __wbg_init_memory(imports);
  const { instance, module } = await __wbg_load(await input, imports);
  return __wbg_finalize_init(instance, module);
}
var transit_rs_default = __wbg_init;

// transit/transit.ts
var AU_km2 = 1496e5;
function generate() {
  let table = document.getElementById("output-table");
  let dropDown = document.getElementById("location-drop-down");
  let canvas = document.getElementById("orbital-canvas");
  let orbits = {};
  for (const key in space_time) {
    let opt = document.createElement("option");
    let body = space_time[key];
    opt.value = key;
    opt.innerHTML = body.name;
    dropDown.appendChild(opt);
    orbits[key] = new Orbit(
      body.semiMajorAxis_0_km,
      body.eccentricity_0,
      body.inclination_0_deg,
      body.longitudOfAscendingNode_0_deg,
      body.argumentOfPeriapsis_0_deg,
      body.trueAnomaly_0_deg,
      body.GM_km3_s2,
      body.GM_km3_s2_primary,
      body.radius_km
    );
    orbits[key].updatePosition(Date.now() - 9466848e5);
  }
  const infiniteCanvas = new InfiniteCanvas(canvas);
  infiniteCanvas.addDrawFunction(drawSun, checkIfCanvasNeedsUpdating);
  document.addEventListener("contextmenu", (e) => e.preventDefault(), false);
  for (let i in orbits) {
    let o = orbits[i];
    infiniteCanvas.addDrawFunction(o.draw.bind(o), checkIfCanvasNeedsUpdating);
  }
  infiniteCanvas.addDrawFunction(impulseTransfer.bind(this, orbits["Earth"], orbits["Mars"], 1e3), checkIfCanvasNeedsUpdating);
}
function impulseTransfer(bodyStart, bodyEnd, deltaV_km_s, ctx, canvasUnit, reset, currentScale) {
  transit_rs_default().then(() => {
    console.log(add(4, 3));
  });
}
function drawSun(context, displayUnit, reset, currentScale) {
  const radius_km = 696e3;
  let scale = 1 / (5 * AU_km2);
  let radius_px = radius_km * displayUnit * scale;
  context.beginPath();
  context.arc(0, 0, radius_px, 0, 2 * Math.PI);
  context.fillStyle = "white";
  context.fill();
}
var initialDraw = false;
function checkIfCanvasNeedsUpdating() {
  if (initialDraw)
    return false;
  else {
    initialDraw = true;
    return true;
  }
}
window.onload = function() {
  generate();
};
