(() => {
  // space_time/data/celestial_data.js
  var space_time = {
    Mercury: {
      generatedTimeZone: false,
      name: "Mercury",
      GM_km3_s2: 22031.86855,
      radius_km: 2440,
      surface_gravity_ms: 3.7005960343321687,
      semiMajorAxis_0_km: 5790907025241733e-8,
      eccentricity_0: 0.2056302515978038,
      inclination_0_deg: 7.005014362233553,
      longitudOfAscendingNode_0_deg: 48.33053877672862,
      argumentOfPeriapsis_0_deg: 29.12427943500334,
      trueAnomaly_0_deg: 175.1155302923815,
      semiMajorAxis_km_Cy: 0,
      eccentricity_Cy: 0,
      inclination_sec_Cy: 0,
      longitudOfAscendingNode_sec_Cy: 0,
      argumentOfPeriapsis_sec_Cy: 0,
      trueAnomaly_sec_Cy: 0,
      period_ms: 1865409099234155e-2,
      meanAnomaly_0_deg: null
    },
    Venus: {
      generatedTimeZone: false,
      name: "Venus",
      GM_km3_s2: 324858.592,
      radius_km: 6051.893,
      surface_gravity_ms: 8.869760144761234,
      semiMajorAxis_0_km: 1082081565316098e-7,
      eccentricity_0: 0.006755697268576816,
      inclination_0_deg: 3.394589632757466,
      longitudOfAscendingNode_0_deg: 76.6783751109416,
      argumentOfPeriapsis_0_deg: 55.18541504725159,
      trueAnomaly_0_deg: 49.90452231912491,
      semiMajorAxis_km_Cy: 0,
      eccentricity_Cy: 0,
      inclination_sec_Cy: 0,
      longitudOfAscendingNode_sec_Cy: 0,
      argumentOfPeriapsis_sec_Cy: 0,
      trueAnomaly_sec_Cy: 0,
      period_ms: 12408597200354518e-3,
      meanAnomaly_0_deg: null
    },
    Earth: {
      generatedTimeZone: true,
      name: "Earth",
      dayLength_ms: 864e5,
      yearLength_ms: 31558149e3,
      yearLength_hd: 365,
      hDayLength_ms: 864e5,
      weekLength_d: 7,
      weekLength_hd: 7,
      hYearLength_ms: 31536e6,
      monthCount: 12,
      nominalMonthLength_hd: 30,
      nominalMonthLength_ms: 2592e6,
      leapYearFreq_hd: [4, 158],
      leapYearBlocks_ms: [1262304e5, 4986144e6],
      monthRemainder_hd: 5,
      initialWeekDay: 6,
      initialYearProgress: 0,
      GM_km3_s2: 398600.435436,
      radius_km: 6378.137,
      surface_gravity_ms: 9.798285322749217,
      semiMajorAxis_0_km: 1496534962738141e-7,
      eccentricity_0: 0.01704239718110438,
      inclination_0_deg: 2668809336274974e-19,
      longitudOfAscendingNode_0_deg: 163.9748712430063,
      argumentOfPeriapsis_0_deg: 297.7671795415902,
      trueAnomaly_0_deg: 358.1260865474801,
      semiMajorAxis_km_Cy: 0,
      eccentricity_Cy: 0,
      inclination_sec_Cy: 0,
      longitudOfAscendingNode_sec_Cy: 0,
      argumentOfPeriapsis_sec_Cy: 0,
      trueAnomaly_sec_Cy: 0,
      period_ms: 18219702661829465e-3,
      meanAnomaly_0_deg: null
    },
    Mars: {
      generatedTimeZone: true,
      name: "Mars",
      dayLength_ms: 88775e3,
      yearLength_ms: 59266496e3,
      yearLength_hd: 667,
      hDayLength_ms: 88775e3,
      weekLength_d: 7,
      weekLength_hd: 7,
      hYearLength_ms: 59212925e3,
      monthCount: 24,
      nominalMonthLength_hd: 27,
      nominalMonthLength_ms: 2396925e3,
      leapYearFreq_hd: [2, 10],
      leapYearBlocks_ms: [118514625e3, 5926619e5],
      monthRemainder_hd: 19,
      initialWeekDay: 0,
      initialYearProgress: 0,
      GM_km3_s2: 42828.375214,
      radius_km: 3396.19,
      surface_gravity_ms: 3.7131940089349422,
      semiMajorAxis_0_km: 2279390120013493e-7,
      eccentricity_0: 0.0933146065415545,
      inclination_0_deg: 1.849876654038142,
      longitudOfAscendingNode_0_deg: 49.56199905920329,
      argumentOfPeriapsis_0_deg: 286.5373583154345,
      trueAnomaly_0_deg: 23.02024685501411,
      semiMajorAxis_km_Cy: 0,
      eccentricity_Cy: 0,
      inclination_sec_Cy: 0,
      longitudOfAscendingNode_sec_Cy: 0,
      argumentOfPeriapsis_sec_Cy: 0,
      trueAnomaly_sec_Cy: 0,
      period_ms: 10448214047350531e-2,
      meanAnomaly_0_deg: null
    },
    Ceres: {
      generatedTimeZone: true,
      name: "Ceres",
      dayLength_ms: 32667e3,
      yearLength_ms: 145423789e3,
      yearLength_hd: 1712,
      weekLength_d: 13,
      weekLength_hd: 5,
      hDayLength_ms: 84934e3,
      hYearLength_ms: 145407008e3,
      monthCount: 84,
      nominalMonthLength_hd: 20,
      nominalMonthLength_ms: 169868e4,
      leapYearFreq_hd: [6, 33],
      leapYearBlocks_ms: [872526982e3, 4798940868e3],
      monthRemainder_hd: 32,
      initialWeekDay: 0,
      initialYearProgress: 0,
      GM_km3_s2: 62.6325,
      radius_km: 469.7,
      surface_gravity_ms: 0.2838955771940551,
      semiMajorAxis_0_km: 4138616544134015e-7,
      eccentricity_0: 0.07837505504042046,
      inclination_0_deg: 10.58336067354914,
      longitudOfAscendingNode_0_deg: 80.49436497118826,
      argumentOfPeriapsis_0_deg: 73.92278732202695,
      trueAnomaly_0_deg: 7.121193766358798,
      semiMajorAxis_km_Cy: 0,
      eccentricity_Cy: 0,
      inclination_sec_Cy: 0,
      longitudOfAscendingNode_sec_Cy: 0,
      argumentOfPeriapsis_sec_Cy: 0,
      trueAnomaly_sec_Cy: 0,
      period_ms: 6684405364675394,
      meanAnomaly_0_deg: null
    },
    Jupiter: {
      generatedTimeZone: false,
      name: "Jupiter",
      GM_km3_s2: 1266865319e-1,
      radius_km: 71492,
      surface_gravity_ms: 24.786519847888645,
      semiMajorAxis_0_km: 7786731611090481e-7,
      eccentricity_0: 0.04892305962953223,
      inclination_0_deg: 1.304655711046047,
      longitudOfAscendingNode_0_deg: 100.4888615724618,
      argumentOfPeriapsis_0_deg: 275.1197059498091,
      trueAnomaly_0_deg: 20.63463654069944,
      semiMajorAxis_km_Cy: 0,
      eccentricity_Cy: 0,
      inclination_sec_Cy: 0,
      longitudOfAscendingNode_sec_Cy: 0,
      argumentOfPeriapsis_sec_Cy: 0,
      trueAnomaly_sec_Cy: 0,
      period_ms: 12129627211583168e-3,
      meanAnomaly_0_deg: null
    },
    Europa: {
      generatedTimeZone: true,
      name: "Europa",
      dayLength_ms: 306822e3,
      yearLength_ms: 374335776e3,
      yearLength_hd: 4270,
      weekLength_d: 2,
      weekLength_hd: 7,
      hDayLength_ms: 87663e3,
      hYearLength_ms: 37432101e4,
      monthCount: 152,
      nominalMonthLength_hd: 28,
      nominalMonthLength_ms: 2454564e3,
      leapYearFreq_hd: [6, 564],
      leapYearBlocks_ms: [2246013723e3, 211125377625e3],
      monthRemainder_hd: 14,
      initialWeekDay: 0,
      initialYearProgress: 0
    },
    Ganymede: {
      generatedTimeZone: true,
      name: "Ganymede",
      dayLength_ms: 618153e3,
      yearLength_ms: 374335776e3,
      yearLength_hd: 4239,
      weekLength_d: 1,
      weekLength_hd: 7,
      hDayLength_ms: 88307e3,
      hYearLength_ms: 374333373e3,
      monthCount: 148,
      nominalMonthLength_hd: 28,
      nominalMonthLength_ms: 2472596e3,
      leapYearFreq_hd: [37, 5410],
      leapYearBlocks_ms: [13850423108e3, 2025156529059e3],
      monthRemainder_hd: 95,
      initialWeekDay: 0,
      initialYearProgress: 0
    },
    Callisto: {
      generatedTimeZone: true,
      name: "Callisto",
      dayLength_ms: 1441931e3,
      yearLength_ms: 374335776e3,
      yearLength_hd: 4413,
      weekLength_d: 1,
      weekLength_hd: 17,
      hDayLength_ms: 84819e3,
      hYearLength_ms: 374306247e3,
      monthCount: 64,
      nominalMonthLength_hd: 68,
      nominalMonthLength_ms: 5767692e3,
      leapYearFreq_hd: [3, 68],
      leapYearBlocks_ms: [112300356e4, 25454775633e3],
      monthRemainder_hd: 61,
      initialWeekDay: 0,
      initialYearProgress: 0
    },
    Saturn: {
      generatedTimeZone: false,
      name: "Saturn",
      GM_km3_s2: 37931206234e-3,
      radius_km: 60268,
      surface_gravity_ms: 10.442947496734448,
      semiMajorAxis_0_km: 1433364815997285e-6,
      eccentricity_0: 0.05559928887285597,
      inclination_0_deg: 2.48436877980734,
      longitudOfAscendingNode_0_deg: 113.6930130794106,
      argumentOfPeriapsis_0_deg: 335.9006492558044,
      trueAnomaly_0_deg: 316.0917716241848,
      semiMajorAxis_km_Cy: 0,
      eccentricity_Cy: 0,
      inclination_sec_Cy: 0,
      longitudOfAscendingNode_sec_Cy: 0,
      argumentOfPeriapsis_sec_Cy: 0,
      trueAnomaly_sec_Cy: 0,
      period_ms: 5536262212547909e-2,
      meanAnomaly_0_deg: null
    },
    Titan: {
      generatedTimeZone: true,
      name: "Titan",
      dayLength_ms: 1377648e3,
      yearLength_ms: 929596607e3,
      yearLength_hd: 10796,
      weekLength_d: 1,
      weekLength_hd: 16,
      hDayLength_ms: 86103e3,
      hYearLength_ms: 929567988e3,
      monthCount: 168,
      nominalMonthLength_hd: 64,
      nominalMonthLength_ms: 5510592e3,
      leapYearFreq_hd: [4, 13],
      leapYearBlocks_ms: [3718358055e3, 12084728256e3],
      monthRemainder_hd: 44,
      initialWeekDay: 0,
      initialYearProgress: 0
    },
    Enceladus: {
      generatedTimeZone: true,
      name: "Enceladus",
      dayLength_ms: 118386e3,
      yearLength_ms: 929596607e3,
      yearLength_hd: 10993,
      weekLength_d: 5,
      weekLength_hd: 7,
      hDayLength_ms: 84561e3,
      hYearLength_ms: 929579073e3,
      monthCount: 392,
      nominalMonthLength_hd: 28,
      nominalMonthLength_ms: 2367708e3,
      leapYearFreq_hd: [5, 136],
      leapYearBlocks_ms: [4647979926e3, 126425121636e3],
      monthRemainder_hd: 17,
      initialWeekDay: 0,
      initialYearProgress: 0
    },
    Uranus: {
      generatedTimeZone: false,
      name: "Uranus",
      GM_km3_s2: 5793951256e-3,
      radius_km: 25559,
      surface_gravity_ms: 8.8692545868098,
      semiMajorAxis_0_km: 2876758957338404e-6,
      eccentricity_0: 0.04439336258840319,
      inclination_0_deg: 0.7723604869115734,
      longitudOfAscendingNode_0_deg: 73.96006633963485,
      argumentOfPeriapsis_0_deg: 96.61122696481169,
      trueAnomaly_0_deg: 145.8440420932308,
      semiMajorAxis_km_Cy: 0,
      eccentricity_Cy: 0,
      inclination_sec_Cy: 0,
      longitudOfAscendingNode_sec_Cy: 0,
      argumentOfPeriapsis_sec_Cy: 0,
      trueAnomaly_sec_Cy: 0,
      period_ms: 40276123214276875e-2,
      meanAnomaly_0_deg: null
    },
    Titania: {
      generatedTimeZone: true,
      name: "Titania",
      dayLength_ms: 752218e3,
      yearLength_ms: 26514864e5,
      yearLength_hd: 31724,
      weekLength_d: 1,
      weekLength_hd: 9,
      hDayLength_ms: 83579e3,
      hYearLength_ms: 2651460196e3,
      monthCount: 880,
      nominalMonthLength_hd: 36,
      nominalMonthLength_ms: 3008844e3,
      leapYearFreq_hd: [4, 16],
      leapYearBlocks_ms: [10605924363e3, 42423781031e3],
      monthRemainder_hd: 44,
      initialWeekDay: 0,
      initialYearProgress: 0
    },
    Neptune: {
      generatedTimeZone: false,
      name: "Neptune",
      GM_km3_s2: 683509997e-2,
      radius_km: 24766,
      surface_gravity_ms: 11.14379550029934,
      semiMajorAxis_0_km: 4503002396427352e-6,
      eccentricity_0: 0.01127490587339749,
      inclination_0_deg: 1.764331194766304,
      longitudOfAscendingNode_0_deg: 131.8103417756993,
      argumentOfPeriapsis_0_deg: 266.115451343762,
      trueAnomaly_0_deg: 265.9963939182547,
      semiMajorAxis_km_Cy: 0,
      eccentricity_Cy: 0,
      inclination_sec_Cy: 0,
      longitudOfAscendingNode_sec_Cy: 0,
      argumentOfPeriapsis_sec_Cy: 0,
      trueAnomaly_sec_Cy: 0,
      period_ms: 726207450158298,
      meanAnomaly_0_deg: null
    },
    Triton: {
      generatedTimeZone: true,
      name: "Triton",
      dayLength_ms: 50776e4,
      yearLength_ms: 51997248e5,
      yearLength_hd: 61443,
      weekLength_d: 1,
      weekLength_hd: 6,
      hDayLength_ms: 84626e3,
      hYearLength_ms: 5199675318e3,
      monthCount: 2560,
      nominalMonthLength_hd: 24,
      nominalMonthLength_ms: 2031024e3,
      leapYearFreq_hd: [2, 12],
      leapYearBlocks_ms: [10399435262e3, 62396696198e3],
      monthRemainder_hd: 3,
      initialWeekDay: 0,
      initialYearProgress: 0
    }
  };

  // transit/map.ts
  var AU_km = 1496e5;
  var scalePerKm = 1 / (5 * AU_km);
  var Orbit = class {
    constructor(a_km, e, i_deg, longitudeOfAscendingNode_deg, argumentOfPeriapsis_deg, meanAnomaly_deg, GM_km3_s2, radius_km) {
      this.positionVector_inertialFrame = [0, 0, 0];
      this.semiMajorAxis_km = a_km;
      this.eccentricity = e;
      this.inclination_deg = i_deg;
      this.longitudOfAscendingNode_deg = longitudeOfAscendingNode_deg;
      this.argumentOfPeriapsis_deg = argumentOfPeriapsis_deg;
      this.meanAnomaly_0_deg = meanAnomaly_deg;
      this.semiMinorAxis_km = a_km * (1 - this.eccentricity);
      this.GM_km3_s2 = GM_km3_s2;
      this.radius_km = radius_km;
    }
    draw(ctx, canvasUnit, reset, currentScale) {
      if (this.semiMajorAxis_km == void 0)
        return;
      console.log("true: " + this.eccentricAnomaly_deg + ", mean: " + this.meanAnomaly_deg);
      let scale = canvasUnit * scalePerKm;
      let ellipseCenter = {
        x: Math.cos(degToRad(this.longitudOfAscendingNode_deg + this.argumentOfPeriapsis_deg)) * this.eccentricity * this.semiMajorAxis_km * scale,
        y: Math.sin(degToRad(this.longitudOfAscendingNode_deg + this.argumentOfPeriapsis_deg)) * this.eccentricity * this.semiMajorAxis_km * scale
      };
      ctx.beginPath();
      ctx.fillStyle = "coral";
      ctx.arc(this.positionVector_inertialFrame[0] * scale, this.positionVector_inertialFrame[1] * scale, 5 / currentScale, 0, 2 * Math.PI);
      ctx.fill();
      let largeSide = this.semiMajorAxis_km * scale * 1.1;
      var width = 0.5 / currentScale;
      ctx.lineWidth = width;
      var brightHalf = ctx.createLinearGradient(
        -largeSide * Math.sin(degToRad(this.eccentricAnomaly_deg)),
        largeSide * Math.cos(degToRad(this.eccentricAnomaly_deg)),
        largeSide * Math.sin(degToRad(this.eccentricAnomaly_deg)),
        -largeSide * Math.cos(degToRad(this.eccentricAnomaly_deg))
      );
      brightHalf.addColorStop(0, "white");
      brightHalf.addColorStop(1, "DimGray");
      var darkHalf = ctx.createLinearGradient(
        -largeSide * Math.sin(degToRad(this.eccentricAnomaly_deg)),
        largeSide * Math.cos(degToRad(this.eccentricAnomaly_deg)),
        largeSide * Math.sin(degToRad(this.eccentricAnomaly_deg)),
        -largeSide * Math.cos(degToRad(this.eccentricAnomaly_deg))
      );
      darkHalf.addColorStop(0, "#202020");
      darkHalf.addColorStop(1, "DimGray");
      ctx.save();
      ctx.beginPath();
      ctx.rotate(degToRad(this.eccentricAnomaly_deg));
      ctx.rect(ellipseCenter.x - largeSide - width, ellipseCenter.y - largeSide - width, largeSide + width * 2, (largeSide + width) * 2);
      reset();
      ctx.clip();
      ctx.strokeStyle = brightHalf;
      ctx.beginPath();
      ctx.ellipse(
        ellipseCenter.x,
        ellipseCenter.y,
        this.semiMajorAxis_km * scale,
        this.semiMinorAxis_km * scale,
        degToRad(this.longitudOfAscendingNode_deg + this.argumentOfPeriapsis_deg),
        0 * Math.PI,
        2 * Math.PI
      );
      ctx.stroke();
      ctx.restore();
      ctx.save();
      ctx.beginPath();
      ctx.rotate(degToRad(this.eccentricAnomaly_deg));
      ctx.rect(ellipseCenter.x - width, ellipseCenter.y - largeSide - width, largeSide + width * 2, (largeSide + width) * 2);
      reset();
      ctx.clip();
      ctx.strokeStyle = darkHalf;
      ctx.beginPath();
      ctx.ellipse(
        ellipseCenter.x,
        ellipseCenter.y,
        this.semiMajorAxis_km * scale,
        this.semiMinorAxis_km * scale,
        degToRad(this.longitudOfAscendingNode_deg + this.argumentOfPeriapsis_deg),
        0 * Math.PI,
        2 * Math.PI
      );
      ctx.stroke();
      ctx.restore();
    }
    keplersEquation(E_rad) {
      return E_rad - this.eccentricity * Math.sin(E_rad) - radToDeg(this.meanAnomaly_deg);
    }
    updatePosition(t_ms) {
      this.meanAnomaly_deg = (this.meanAnomaly_0_deg + t_ms * (this.GM_km3_s2 / this.semiMajorAxis_km ** 3) ** 0.5) % 360;
      let eccentricAnomaly_rad = newtonRaphson(this.keplersEquation.bind(this), degToRad(this.meanAnomaly_deg), null);
      this.eccentricAnomaly_deg = radToDeg(eccentricAnomaly_rad);
      let trueAnomaly_rad = 2 * Math.atan2(
        (1 + this.eccentricity) ** 0.5 * Math.sin(eccentricAnomaly_rad / 2),
        (1 - this.eccentricity) ** 0.5 * Math.cos(eccentricAnomaly_rad / 2)
      );
      let distanceToCenter = this.semiMajorAxis_km * (1 - this.eccentricity * Math.cos(eccentricAnomaly_rad));
      console.log(
        "Mean anomaly: " + this.meanAnomaly_deg + " deg | Eccentric anomaly: " + radToDeg(eccentricAnomaly_rad) % 360 + " deg | Radius = " + distanceToCenter
      );
      let positionVector_perifocalFrame = new Array(3);
      positionVector_perifocalFrame[0] = distanceToCenter * Math.cos(trueAnomaly_rad);
      positionVector_perifocalFrame[1] = distanceToCenter * Math.sin(trueAnomaly_rad);
      positionVector_perifocalFrame[2] = 0;
      let argumentOfPeriapsis_rad = degToRad(this.argumentOfPeriapsis_deg);
      let inclination_rad = degToRad(this.inclination_deg);
      let longitudOfAscendingNode_rad = degToRad(this.longitudOfAscendingNode_deg);
      this.positionVector_inertialFrame[0] = positionVector_perifocalFrame[0] * (Math.cos(argumentOfPeriapsis_rad) * Math.cos(longitudOfAscendingNode_rad) - Math.sin(argumentOfPeriapsis_rad) * Math.cos(inclination_rad) * Math.sin(longitudOfAscendingNode_rad)) - positionVector_perifocalFrame[1] * (Math.sin(argumentOfPeriapsis_rad) * Math.cos(longitudOfAscendingNode_rad) + Math.cos(argumentOfPeriapsis_rad) * Math.cos(inclination_rad) * Math.sin(longitudOfAscendingNode_rad));
      this.positionVector_inertialFrame[1] = positionVector_perifocalFrame[0] * (Math.cos(argumentOfPeriapsis_rad) * Math.sin(longitudOfAscendingNode_rad) + Math.sin(argumentOfPeriapsis_rad) * Math.cos(inclination_rad) * Math.cos(longitudOfAscendingNode_rad)) + positionVector_perifocalFrame[1] * (Math.cos(argumentOfPeriapsis_rad) * Math.cos(inclination_rad) * Math.cos(longitudOfAscendingNode_rad) - Math.sin(argumentOfPeriapsis_rad) * Math.sin(longitudOfAscendingNode_rad));
      this.positionVector_inertialFrame[2] = positionVector_perifocalFrame[0] * (Math.sin(argumentOfPeriapsis_rad) * Math.sin(inclination_rad)) - positionVector_perifocalFrame[1] * (Math.cos(argumentOfPeriapsis_rad) * Math.sin(inclination_rad));
      console.log(
        "Perifocal: " + positionVector_perifocalFrame[0] / AU_km + " AU | " + positionVector_perifocalFrame[1] / AU_km + " AU | " + positionVector_perifocalFrame[2] + " km"
      );
      console.log(
        "Inertial: " + this.positionVector_inertialFrame[0] / AU_km + " AU | " + this.positionVector_inertialFrame[1] / AU_km + " AU | " + this.positionVector_inertialFrame[2] + " km"
      );
    }
  };
  function newtonRaphson(f, x0, options) {
    var x1, y, yp, tol, maxIter, iter, yph, ymh, yp2h, ym2h, h, hr, verbose, eps;
    let fp = null;
    options = options || {};
    tol = options.tolerance === void 0 ? 1e-7 : options.tolerance;
    eps = options.epsilon === void 0 ? 2220446049250313e-31 : options.epsilon;
    maxIter = options.maxIterations === void 0 ? 20 : options.maxIterations;
    h = options.h === void 0 ? 1e-4 : options.h;
    verbose = options.verbose === void 0 ? false : options.verbose;
    hr = 1 / h;
    iter = 0;
    while (iter++ < maxIter) {
      y = f(x0);
      yph = f(x0 + h);
      ymh = f(x0 - h);
      yp2h = f(x0 + 2 * h);
      ym2h = f(x0 - 2 * h);
      yp = (ym2h - yp2h + 8 * (yph - ymh)) * hr / 12;
      if (Math.abs(yp) <= eps * Math.abs(y)) {
        if (verbose) {
          console.log("Newton-Raphson: failed to converged due to nearly zero first derivative");
        }
        return 0;
      }
      x1 = x0 - y / yp;
      if (Math.abs(x1 - x0) <= tol * Math.abs(x1)) {
        if (verbose) {
          console.log("Newton-Raphson: converged to x = " + x1 + " after " + iter + " iterations");
        }
        return x1;
      }
      x0 = x1;
    }
    if (verbose) {
      console.log("Newton-Raphson: Maximum iterations reached (" + maxIter + ")");
    }
    return 0;
  }
  function degToRad(degrees) {
    return degrees * (Math.PI / 180);
  }
  function radToDeg(radians) {
    return radians * (180 / Math.PI);
  }

  // transit/infinite_canvas.ts
  var view = /* @__PURE__ */ (() => {
    const matrix = [1, 0, 0, 1, 0, 0];
    var m = matrix;
    var scale = 1;
    var ctx;
    const pos = { x: 0, y: 0 };
    var dirty = true;
    const API = {
      set context(_ctx) {
        ctx = _ctx;
        dirty = true;
      },
      apply() {
        if (dirty) {
          this.update();
        }
        ctx.setTransform(m[0], m[1], m[2], m[3], m[4], m[5]);
      },
      get scale() {
        return scale;
      },
      get position() {
        return pos;
      },
      setDirty() {
        dirty = true;
      },
      isDirty() {
        return dirty;
      },
      update() {
        dirty = false;
        m[3] = m[0] = scale;
        m[2] = m[1] = 0;
        m[4] = pos.x;
        m[5] = pos.y;
      },
      pan(amount) {
        if (dirty) {
          this.update();
        }
        pos.x += amount.x;
        pos.y += amount.y;
        dirty = true;
      },
      scaleAt(at, amount) {
        if (dirty) {
          this.update();
        }
        scale *= amount;
        pos.x = at.x - (at.x - pos.x) * amount;
        pos.y = at.y - (at.y - pos.y) * amount;
        dirty = true;
      }
    };
    return API;
  })();
  var InfiniteCanvas = class {
    constructor(canvas) {
      this.#pixelRatio = window.devicePixelRatio;
      this.cameraZoom = 1;
      this.MAX_ZOOM = 5;
      this.MIN_ZOOM = 0.1;
      this.SCROLL_SENSITIVITY = 5e-4;
      this.isDragging = false;
      this.dragStart = { x: 0, y: 0 };
      this.cameraOffset = { x: 0, y: 0 };
      this.initialPinchDistance = 0;
      this.lastZoom = 1;
      this.lastDrawnZoom = 1;
      this.mouse = { x: 0, y: 0, oldX: 0, oldY: 0, button: false };
      this.#drawFunctions = [];
      this.#needsUpdating = [];
      let temp_context = canvas.getContext("2d");
      if (!temp_context) {
        console.log("Failed to get context");
        return;
      }
      view.context = temp_context;
      this.context = temp_context;
      this.canvas = canvas;
      this.#setupEvents(canvas);
      this.canvas.width = this.canvas.clientWidth * this.#pixelRatio;
      this.canvas.height = this.canvas.clientHeight * this.#pixelRatio;
      this.cameraOffset.x = this.canvas.width / 2;
      this.cameraOffset.y = this.canvas.height / 2;
      view.pan({ x: this.canvas.width / 2, y: this.canvas.height / 2 });
      this.#draw();
    }
    #pixelRatio;
    #drawFunctions;
    #needsUpdating;
    addDrawFunction(drawFunction, needsUpdating) {
      this.#drawFunctions.push(drawFunction);
      this.#needsUpdating.push(needsUpdating);
    }
    #draw() {
      if (view.isDirty() || this.#needsUpdating.length && this.#needsUpdating.some((e) => e())) {
        this.canvas.width = this.canvas.clientWidth * this.#pixelRatio;
        this.canvas.height = this.canvas.clientHeight * this.#pixelRatio;
        this.context.setTransform(1, 0, 0, 1, 0, 0);
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
        view.apply();
        let that = this;
        if (this.#drawFunctions.length)
          this.#drawFunctions.map((f) => f(that.context, that.canvas.width / 2, view.apply, view.scale));
      }
      requestAnimationFrame(this.#draw.bind(this));
    }
    #setupEvents(canvas) {
      canvas.addEventListener("mousemove", this.mouseEvent.bind(this), { passive: true });
      canvas.addEventListener("mousedown", this.mouseEvent.bind(this), { passive: true });
      canvas.addEventListener("mouseup", this.mouseEvent.bind(this), { passive: true });
      canvas.addEventListener("mouseout", this.mouseEvent.bind(this), { passive: true });
      canvas.addEventListener("wheel", this.mouseWheelEvent.bind(this), { passive: false });
      window.addEventListener("resize", () => view.setDirty());
    }
    mouseEvent(event) {
      if (event.type === "mousedown") {
        this.mouse.button = true;
      }
      if (event.type === "mouseup" || event.type === "mouseout") {
        this.mouse.button = false;
      }
      this.mouse.oldX = this.mouse.x;
      this.mouse.oldY = this.mouse.y;
      this.mouse.x = event.offsetX;
      this.mouse.y = event.offsetY;
      if (this.mouse.button) {
        view.pan({ x: this.mouse.x - this.mouse.oldX, y: this.mouse.y - this.mouse.oldY });
      }
    }
    mouseWheelEvent(event) {
      var x = event.offsetX;
      var y = event.offsetY;
      if (event.deltaY < 0) {
        view.scaleAt({ x, y }, 1.1);
      } else {
        view.scaleAt({ x, y }, 1 / 1.1);
      }
      event.preventDefault();
    }
    // Gets the relevant location from a mouse or single touch event
    // #getEventLocation(e: TouchEvent | MouseEvent): { x: number; y: number } {
    // 	if (e instanceof MouseEvent && e.clientX && e.clientY) {
    // 		return { x: e.clientX, y: e.clientY };
    // 	} else if (e instanceof TouchEvent && e.touches && e.touches.length == 1) {
    // 		return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    // 	} else return { x: 0, y: 0 };
    // }
    // #onPointerDown(e: TouchEvent | MouseEvent): void {
    // 	this.isDragging = true;
    // 	this.dragStart.x = this.#getEventLocation(e).x / this.cameraZoom - this.cameraOffset.x;
    // 	this.dragStart.y = this.#getEventLocation(e).y / this.cameraZoom - this.cameraOffset.y;
    // }
    // #onPointerUp(e: TouchEvent | MouseEvent): void {
    // 	this.isDragging = false;
    // 	this.initialPinchDistance = null;
    // 	this.lastZoom = this.cameraZoom;
    // }
    // #onPointerMove(e: TouchEvent | MouseEvent): void {
    // 	if (this.isDragging) {
    // 		this.cameraOffset.x = this.#getEventLocation(e).x / this.cameraZoom - this.dragStart.x;
    // 		this.cameraOffset.y = this.#getEventLocation(e).y / this.cameraZoom - this.dragStart.y;
    // 	}
    // 	var rect = this.canvas.getBoundingClientRect();
    // 	this.#pointerPos.x =
    // 		(((this.#getEventLocation(e).x - rect.left) / (rect.right - rect.left)) * this.canvas.width) / this.cameraZoom - this.cameraOffset.x;
    // 	this.#pointerPos.y =
    // 		(((this.#getEventLocation(e).y - rect.top) / (rect.bottom - rect.top)) * this.canvas.height) / this.cameraZoom - this.cameraOffset.y;
    // }
    // #handleTouch(e: TouchEvent, singleTouchHandler: (e: TouchEvent) => void) {
    // 	if (e.touches.length == 1) {
    // 		singleTouchHandler(e);
    // 	} else if (e.type == "touchmove" && e.touches.length == 2) {
    // 		this.isDragging = false;
    // 		this.#handlePinch(e);
    // 	}
    // }
    // #handlePinch(e: TouchEvent) {
    // 	e.preventDefault();
    // 	let touch1 = { x: e.touches[0].clientX, y: e.touches[0].clientY };
    // 	let touch2 = { x: e.touches[1].clientX, y: e.touches[1].clientY };
    // 	// This is distance squared, but no need for an expensive sqrt as it's only used in ratio
    // 	let currentDistance = (touch1.x - touch2.x) ** 2 + (touch1.y - touch2.y) ** 2;
    // 	if (initialPinchDistance == null) {
    // 		initialPinchDistance = currentDistance;
    // 	} else {
    // 		this.#adjustZoom(null, currentDistance / initialPinchDistance);
    // 	}
    // }
    // #adjustZoom(zoomAmount: number, zoomFactor: number = null): void {
    // 	if (!this.isDragging) {
    // 		if (zoomAmount) {
    // 			this.cameraZoom += zoomAmount;
    // 		} else if (zoomFactor) {
    // 			console.log(zoomFactor);
    // 			this.cameraZoom = zoomFactor * lastZoom;
    // 		}
    // 		this.cameraZoom = Math.min(this.cameraZoom, this.MAX_ZOOM);
    // 		this.cameraZoom = Math.max(this.cameraZoom, this.MIN_ZOOM);
    // 	}
    // }
  };

  // transit/transit.ts
  var AU_km2 = 1496e5;
  function generate() {
    let table = document.getElementById("output-table");
    let dropDown = document.getElementById("location-drop-down");
    let canvas = document.getElementById("orbital-canvas");
    let orbits = [];
    for (const key in space_time) {
      let opt = document.createElement("option");
      let body = space_time[key];
      opt.value = key;
      opt.innerHTML = body.name;
      dropDown.appendChild(opt);
      orbits.push(
        new Orbit(
          body.semiMajorAxis_0_km,
          body.eccentricity_0,
          body.inclination_0_deg,
          body.longitudOfAscendingNode_0_deg,
          body.argumentOfPeriapsis_0_deg,
          body.trueAnomaly_0_deg,
          body.GM_km3_s2,
          body.radius_km
        )
      );
      console.log(body.name);
      orbits.at(-1)?.updatePosition(0);
    }
    generateCanvas(canvas, orbits);
  }
  function drawSun(context, displayUnit, reset, currentScale) {
    const radius_km = 696e3;
    let scale = 1 / (5 * AU_km2);
    let radius_px = radius_km * displayUnit * scale;
    context.beginPath();
    context.arc(0, 0, radius_px, 0, 2 * Math.PI);
    context.fillStyle = "white";
    context.fill();
  }
  var initialDraw = false;
  function checkIfCanvasNeedsUpdating() {
    if (initialDraw)
      return false;
    else {
      initialDraw = true;
      return true;
    }
  }
  function generateCanvas(canvas, orbits) {
    const infiniteCanvas = new InfiniteCanvas(canvas);
    infiniteCanvas.addDrawFunction(drawSun, checkIfCanvasNeedsUpdating);
    document.addEventListener("contextmenu", (e) => e.preventDefault(), false);
    orbits.forEach((o) => {
      infiniteCanvas.addDrawFunction(o.draw.bind(o), checkIfCanvasNeedsUpdating);
    });
  }
  window.onload = function() {
    generate();
  };
})();
